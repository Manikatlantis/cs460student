<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS460 - Assignment 5 Part 3</title>

  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; overflow: hidden; background: black;
    }
  </style>

  <!-- import maps (required by the course) -->
  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

  <script type="importmap-shim">
  {
    "imports": {
      "three": "https://unpkg.com/three@latest/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
    }
  }
  </script>

  <!-- stats.js -->
  <script src="https://mrdoob.github.io/stats.js/build/stats.min.js"></script>
</head>

<body>
<script type="module-shim">
  // Three.js imports
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { AnaglyphEffect } from 'three/addons/effects/AnaglyphEffect.js';
  import { VertexNormalsHelper } from 'three/addons/helpers/VertexNormalsHelper.js';
  import { Pane } from 'https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js';

  // Global variables
  let scene, camera, renderer, controls, effect, stats;
  let dirLight, ambLight;
  const loader = new GLTFLoader();

  // This line fixes texture loading on GitHub Pages
  loader.manager.setURLModifier(url => url);

  // Tweakpane helper object
  window.SCENE = {
    anaglyph: false,
    poly: null,
    rotate_poly: false,
    do_rotate_poly: () => { window.SCENE.rotate_poly = !window.SCENE.rotate_poly; },

    blender: null,
    blender_helper: null,
    rotate_blender: false,
    do_rotate_blender: () => { window.SCENE.rotate_blender = !window.SCENE.rotate_blender; },

    blender_old_material: null,
    change_material: function () {
      if (!this.blender) return;
      if (!this.blender_old_material) {
        this.blender_old_material = this.blender.material.clone();
        this.blender.material = new THREE.MeshNormalMaterial();
      } else {
        this.blender.material = this.blender_old_material.clone();
        this.blender_old_material = null;
      }
    }
  };

  // Scene setup
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
  camera.position.set(0, 10, 30);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  controls = new OrbitControls(camera, renderer.domElement);

  effect = new AnaglyphEffect(renderer);
  effect.setSize(window.innerWidth, window.innerHeight);

  dirLight = new THREE.DirectionalLight(0xffffff, 1);
  dirLight.position.set(5, 10, 7);
  scene.add(dirLight);

  ambLight = new THREE.AmbientLight(0x404060, 0.8);
  scene.add(ambLight);

  // Stats
  stats = new Stats();
  document.body.appendChild(stats.dom);

  // Tweakpane
  const pane = new Pane();
  const ambColor = { value: '#ffffff' };

  const sceneFolder = pane.addFolder({ title: 'Scene' });
  sceneFolder.addBinding(window.SCENE, 'anaglyph');
  sceneFolder.addBinding(dirLight.position, 'x', { min: -100, max: 100, label: 'Light X' });
  sceneFolder.addBinding(dirLight.position, 'y', { min: -100, max: 100, label: 'Light Y' });
  sceneFolder.addBinding(dirLight.position, 'z', { min: -100, max: 100, label: 'Light Z' });
  sceneFolder.addBinding(dirLight, 'intensity', { min: 0, max: 3, label: 'Light Intensity' });
  sceneFolder.addBinding(ambColor, 'value', { label: 'Ambient Color' }).on('change', ev => ambLight.color.set(ev.value));

  // Load original PolyCam model
  loader.load('skull_poly.glb', gltf => {
    const poly = gltf.scene.children[0];
    poly.scale.set(50, 50, 50);
    poly.quaternion.set(0, 0, 0, 1);
    poly.position.set(8, 0, 0);
    scene.add(gltf.scene);
    window.SCENE.poly = poly;

    const polyFolder = pane.addFolder({ title: 'PolyCam Mesh' });
    polyFolder.addBinding(poly.material, 'wireframe');
    polyFolder.addButton({ title: 'rotate!' }).on('click', () => window.SCENE.do_rotate_poly());
  });

  // Load edited Blender model
  loader.load('skull_final.glb', gltf => {
    const blender = gltf.scene.children[0];
    blender.scale.set(50, 50, 50);
    blender.quaternion.set(0, 0, 0, 1);
    blender.position.set(-8, 0, 0);
    scene.add(gltf.scene);
    window.SCENE.blender = blender;

    const helper = new VertexNormalsHelper(blender, 0.15, 0x00ffff);
    helper.visible = false;
    scene.add(helper);
    window.SCENE.blender_helper = helper;

    const blenderFolder = pane.addFolder({ title: 'Blender Mesh' });
    blenderFolder.addBinding(helper, 'visible', { label: 'Show normals!' });
    blenderFolder.addButton({ title: 'Change Material!' }).on('click', () => window.SCENE.change_material());
    blenderFolder.addButton({ title: 'rotate!' }).on('click', () => window.SCENE.do_rotate_blender());
  });

  // Resize handler
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    effect.setSize(window.innerWidth, window.innerHeight);
  });

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);

    // PolyCam rotation
    if (window.SCENE.poly) {
      const targetQ = window.SCENE.rotate_poly
        ? new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI)
        : new THREE.Quaternion(0, 0, 0, 1);
      window.SCENE.poly.quaternion.slerp(targetQ, 0.02);
    }

    // Blender rotation + update normals helper
    if (window.SCENE.blender) {
      const targetQ = window.SCENE.rotate_blender
        ? new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI)
        : new THREE.Quaternion(0, 0, 0, 1);
      window.SCENE.blender.quaternion.slerp(targetQ, 0.02);

      if (window.SCENE.blender_helper) window.SCENE.blender_helper.update();
    }

    controls.update();

    if (window.SCENE.anaglyph) effect.render(scene, camera);
    else renderer.render(scene, camera);

    stats.update();
  }

  animate();
</script>
</body>
</html>